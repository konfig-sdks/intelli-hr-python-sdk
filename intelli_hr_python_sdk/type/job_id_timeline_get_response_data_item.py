# coding: utf-8

"""
    intelliHR Public API

    You can find developer's guide and more documentation on [https://developers.intellihr.io](https://developers.intellihr.io)

    The version of the OpenAPI document: V1
    Contact: support@intellihr.co
    Generated by: https://konfigthis.com
"""

from datetime import datetime, date
import typing
from enum import Enum
from typing_extensions import TypedDict, Literal, TYPE_CHECKING

from intelli_hr_python_sdk.type.custom_fields_response import CustomFieldsResponse

class RequiredJobIdTimelineGetResponseDataItem(TypedDict):
    pass

class OptionalJobIdTimelineGetResponseDataItem(TypedDict, total=False):
    # The timestamp of the group of timeline events. This date will follow the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6).
    groupTime: str

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    businessUnits: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    businessEntities: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    ftes: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    locations: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    positionTitles: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    payGrades: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    renamedPayGrades: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    remunerationSchedules: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    supervisors: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    workClasses: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    workTypes: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    directReportsRemoved: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    directReportsAssigned: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

    extendedLeaveStarted: typing.Union[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]

    extendedLeaveEnded: typing.Union[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]

    # If this event group contains the first change of job attributes (e.g. when a job starts)
    isFirstChange: bool

    # An array of comment objects that annotate the reason for [Job](https://developers.intellihr.io/docs/v1/) changes. Will be an empty array when there has been no updates to the Job.
    comments: typing.Union[typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]

    # If this event group is the start of the given job
    isStartOfJob: bool

    # If this event group is the end of the jobs probation period
    isEndOfProbation: bool

    # If this event group is the end of the given job
    isEndOfJob: bool

    # The type of turnover this end of job is classified as.
    turnoverType: typing.Union[str, none_type]

    # The name of the turnover reason.
    turnoverReason: typing.Union[str, none_type]

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    customFields: typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]

class JobIdTimelineGetResponseDataItem(RequiredJobIdTimelineGetResponseDataItem, OptionalJobIdTimelineGetResponseDataItem):
    pass
