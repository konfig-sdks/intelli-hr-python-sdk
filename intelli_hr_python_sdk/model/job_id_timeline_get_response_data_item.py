# coding: utf-8

"""
    intelliHR Public API

    You can find developer's guide and more documentation on [https://developers.intellihr.io](https://developers.intellihr.io)

    The version of the OpenAPI document: V1
    Contact: support@intellihr.co
    Generated by: https://konfigthis.com
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from intelli_hr_python_sdk import schemas  # noqa: F401


class JobIdTimelineGetResponseDataItem(
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)
    """


    class MetaOapg:
        
        class properties:
            groupTime = schemas.StrSchema
            
            
            class businessUnits(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'businessUnits':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class businessEntities(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'businessEntities':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class ftes(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class value(
                                            schemas.ComposedSchema,
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                one_of_0 = schemas.NoneSchema
                                                one_of_1 = schemas.NumberSchema
                                                
                                                @classmethod
                                                @functools.lru_cache()
                                                def one_of(cls):
                                                    # we need this here to make our import statements work
                                                    # we must store _composed_schemas in here so the code is only run
                                                    # when we invoke this method. If we kept this at the class
                                                    # level we would get an error because the class level
                                                    # code would be run when this module is imported, and these composed
                                                    # classes don't exist yet because their module has not finished
                                                    # loading
                                                    return [
                                                        cls.one_of_0,
                                                        cls.one_of_1,
                                                    ]
                                        
                                        
                                            def __new__(
                                                cls,
                                                *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'value':
                                                return super().__new__(
                                                    cls,
                                                    *args,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                        __annotations__ = {
                                            "value": value,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["value"]) -> MetaOapg.properties.value: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["value", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["value"]) -> typing.Union[MetaOapg.properties.value, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["value", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    value: typing.Union[MetaOapg.properties.value, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        value=value,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'ftes':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class locations(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'locations':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class positionTitles(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        name = schemas.StrSchema
                                        isEnabled = schemas.BoolSchema
                                        code = schemas.AnyTypeSchema
                                        __annotations__ = {
                                            "id": id,
                                            "name": name,
                                            "isEnabled": isEnabled,
                                            "code": code,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["isEnabled"]) -> MetaOapg.properties.isEnabled: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["code"]) -> MetaOapg.properties.code: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "isEnabled", "code", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["isEnabled"]) -> typing.Union[MetaOapg.properties.isEnabled, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["code"]) -> typing.Union[MetaOapg.properties.code, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "isEnabled", "code", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                    isEnabled: typing.Union[MetaOapg.properties.isEnabled, bool, schemas.Unset] = schemas.unset,
                                    code: typing.Union[MetaOapg.properties.code, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        name=name,
                                        isEnabled=isEnabled,
                                        code=code,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'positionTitles':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class payGrades(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'payGrades':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class renamedPayGrades(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'renamedPayGrades':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class remunerationSchedules(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        type = schemas.StrSchema
                                        baseAnnualSalary = schemas.NumberSchema
                                        baseHourlyRate = schemas.NumberSchema
                                        
                                        
                                        class currency(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                regex=[{
                                                    'pattern': r'^[A-Z]{3}$',
                                                }]
                                        hoursPerCycle = schemas.NumberSchema
                                        payCycle = schemas.StrSchema
                                        annualPackage = schemas.NumberSchema
                                        hourlyPackage = schemas.NumberSchema
                                        currencyConversionOccurred = schemas.BoolSchema
                                        
                                        
                                        class employmentCondition(
                                            schemas.DictSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                class properties:
                                                    
                                                    
                                                    class id(
                                                        schemas.StrSchema
                                                    ):
                                                    
                                                    
                                                        class MetaOapg:
                                                            max_length = 36
                                                            min_length = 36
                                                    name = schemas.StrSchema
                                                    
                                                    
                                                    class awardName(
                                                        schemas.ComposedSchema,
                                                    ):
                                                    
                                                    
                                                        class MetaOapg:
                                                            one_of_0 = schemas.StrSchema
                                                            one_of_1 = schemas.NoneSchema
                                                            
                                                            @classmethod
                                                            @functools.lru_cache()
                                                            def one_of(cls):
                                                                # we need this here to make our import statements work
                                                                # we must store _composed_schemas in here so the code is only run
                                                                # when we invoke this method. If we kept this at the class
                                                                # level we would get an error because the class level
                                                                # code would be run when this module is imported, and these composed
                                                                # classes don't exist yet because their module has not finished
                                                                # loading
                                                                return [
                                                                    cls.one_of_0,
                                                                    cls.one_of_1,
                                                                ]
                                                    
                                                    
                                                        def __new__(
                                                            cls,
                                                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                            _configuration: typing.Optional[schemas.Configuration] = None,
                                                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                                        ) -> 'awardName':
                                                            return super().__new__(
                                                                cls,
                                                                *args,
                                                                _configuration=_configuration,
                                                                **kwargs,
                                                            )
                                                    link = schemas.StrSchema
                                                    __annotations__ = {
                                                        "id": id,
                                                        "name": name,
                                                        "awardName": awardName,
                                                        "link": link,
                                                    }
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["awardName"]) -> MetaOapg.properties.awardName: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                            
                                            def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "awardName", "link", ], str]):
                                                # dict_instance[name] accessor
                                                return super().__getitem__(name)
                                            
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["awardName"]) -> typing.Union[MetaOapg.properties.awardName, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                            
                                            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "awardName", "link", ], str]):
                                                return super().get_item_oapg(name)
                                            
                                        
                                            def __new__(
                                                cls,
                                                *args: typing.Union[dict, frozendict.frozendict, ],
                                                id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                                name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                awardName: typing.Union[MetaOapg.properties.awardName, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
                                                link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'employmentCondition':
                                                return super().__new__(
                                                    cls,
                                                    *args,
                                                    id=id,
                                                    name=name,
                                                    awardName=awardName,
                                                    link=link,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                        
                                        
                                        class additions(
                                            schemas.ListSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                
                                                class items(
                                                    schemas.AnyTypeSchema,
                                                ):
                                                
                                                
                                                    class MetaOapg:
                                                        
                                                        class properties:
                                                            name = schemas.StrSchema
                                                            type = schemas.StrSchema
                                                            value = schemas.NumberSchema
                                                            
                                                            
                                                            class currency(
                                                                schemas.StrSchema
                                                            ):
                                                            
                                                            
                                                                class MetaOapg:
                                                                    regex=[{
                                                                        'pattern': r'^[A-Z]{3}$',
                                                                    }]
                                                            __annotations__ = {
                                                                "name": name,
                                                                "type": type,
                                                                "value": value,
                                                                "currency": currency,
                                                            }
                                                
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["value"]) -> MetaOapg.properties.value: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["currency"]) -> MetaOapg.properties.currency: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                                    
                                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        # dict_instance[name] accessor
                                                        return super().__getitem__(name)
                                                    
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["value"]) -> typing.Union[MetaOapg.properties.value, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["currency"]) -> typing.Union[MetaOapg.properties.currency, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                                    
                                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        return super().get_item_oapg(name)
                                                    
                                                
                                                    def __new__(
                                                        cls,
                                                        *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                        type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
                                                        value: typing.Union[MetaOapg.properties.value, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                                        currency: typing.Union[MetaOapg.properties.currency, str, schemas.Unset] = schemas.unset,
                                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                                    ) -> 'items':
                                                        return super().__new__(
                                                            cls,
                                                            *args,
                                                            name=name,
                                                            type=type,
                                                            value=value,
                                                            currency=currency,
                                                            _configuration=_configuration,
                                                            **kwargs,
                                                        )
                                        
                                            def __new__(
                                                cls,
                                                arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                            ) -> 'additions':
                                                return super().__new__(
                                                    cls,
                                                    arg,
                                                    _configuration=_configuration,
                                                )
                                        
                                            def __getitem__(self, i: int) -> MetaOapg.items:
                                                return super().__getitem__(i)
                                        
                                        
                                        class deductions(
                                            schemas.ListSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                
                                                class items(
                                                    schemas.AnyTypeSchema,
                                                ):
                                                
                                                
                                                    class MetaOapg:
                                                        
                                                        class properties:
                                                            name = schemas.StrSchema
                                                            type = schemas.StrSchema
                                                            value = schemas.NumberSchema
                                                            
                                                            
                                                            class currency(
                                                                schemas.StrSchema
                                                            ):
                                                            
                                                            
                                                                class MetaOapg:
                                                                    regex=[{
                                                                        'pattern': r'^[A-Z]{3}$',
                                                                    }]
                                                            __annotations__ = {
                                                                "name": name,
                                                                "type": type,
                                                                "value": value,
                                                                "currency": currency,
                                                            }
                                                
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["value"]) -> MetaOapg.properties.value: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["currency"]) -> MetaOapg.properties.currency: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                                    
                                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        # dict_instance[name] accessor
                                                        return super().__getitem__(name)
                                                    
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["value"]) -> typing.Union[MetaOapg.properties.value, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["currency"]) -> typing.Union[MetaOapg.properties.currency, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                                    
                                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        return super().get_item_oapg(name)
                                                    
                                                
                                                    def __new__(
                                                        cls,
                                                        *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                        type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
                                                        value: typing.Union[MetaOapg.properties.value, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                                        currency: typing.Union[MetaOapg.properties.currency, str, schemas.Unset] = schemas.unset,
                                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                                    ) -> 'items':
                                                        return super().__new__(
                                                            cls,
                                                            *args,
                                                            name=name,
                                                            type=type,
                                                            value=value,
                                                            currency=currency,
                                                            _configuration=_configuration,
                                                            **kwargs,
                                                        )
                                        
                                            def __new__(
                                                cls,
                                                arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                            ) -> 'deductions':
                                                return super().__new__(
                                                    cls,
                                                    arg,
                                                    _configuration=_configuration,
                                                )
                                        
                                            def __getitem__(self, i: int) -> MetaOapg.items:
                                                return super().__getitem__(i)
                                        
                                        
                                        class additionsToTotal(
                                            schemas.ListSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                
                                                class items(
                                                    schemas.AnyTypeSchema,
                                                ):
                                                
                                                
                                                    class MetaOapg:
                                                        
                                                        class properties:
                                                            name = schemas.StrSchema
                                                            type = schemas.StrSchema
                                                            value = schemas.NumberSchema
                                                            
                                                            
                                                            class currency(
                                                                schemas.StrSchema
                                                            ):
                                                            
                                                            
                                                                class MetaOapg:
                                                                    regex=[{
                                                                        'pattern': r'^[A-Z]{3}$',
                                                                    }]
                                                            __annotations__ = {
                                                                "name": name,
                                                                "type": type,
                                                                "value": value,
                                                                "currency": currency,
                                                            }
                                                
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["value"]) -> MetaOapg.properties.value: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["currency"]) -> MetaOapg.properties.currency: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                                    
                                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        # dict_instance[name] accessor
                                                        return super().__getitem__(name)
                                                    
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["value"]) -> typing.Union[MetaOapg.properties.value, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["currency"]) -> typing.Union[MetaOapg.properties.currency, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                                    
                                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        return super().get_item_oapg(name)
                                                    
                                                
                                                    def __new__(
                                                        cls,
                                                        *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                        type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
                                                        value: typing.Union[MetaOapg.properties.value, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                                        currency: typing.Union[MetaOapg.properties.currency, str, schemas.Unset] = schemas.unset,
                                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                                    ) -> 'items':
                                                        return super().__new__(
                                                            cls,
                                                            *args,
                                                            name=name,
                                                            type=type,
                                                            value=value,
                                                            currency=currency,
                                                            _configuration=_configuration,
                                                            **kwargs,
                                                        )
                                        
                                            def __new__(
                                                cls,
                                                arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                            ) -> 'additionsToTotal':
                                                return super().__new__(
                                                    cls,
                                                    arg,
                                                    _configuration=_configuration,
                                                )
                                        
                                            def __getitem__(self, i: int) -> MetaOapg.items:
                                                return super().__getitem__(i)
                                        
                                        
                                        class breakdowns(
                                            schemas.ListSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                
                                                class items(
                                                    schemas.AnyTypeSchema,
                                                ):
                                                
                                                
                                                    class MetaOapg:
                                                        
                                                        class properties:
                                                            name = schemas.StrSchema
                                                            type = schemas.StrSchema
                                                            value = schemas.NumberSchema
                                                            
                                                            
                                                            class currency(
                                                                schemas.StrSchema
                                                            ):
                                                            
                                                            
                                                                class MetaOapg:
                                                                    regex=[{
                                                                        'pattern': r'^[A-Z]{3}$',
                                                                    }]
                                                            __annotations__ = {
                                                                "name": name,
                                                                "type": type,
                                                                "value": value,
                                                                "currency": currency,
                                                            }
                                                
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["value"]) -> MetaOapg.properties.value: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: typing_extensions.Literal["currency"]) -> MetaOapg.properties.currency: ...
                                                    
                                                    @typing.overload
                                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                                    
                                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        # dict_instance[name] accessor
                                                        return super().__getitem__(name)
                                                    
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["value"]) -> typing.Union[MetaOapg.properties.value, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: typing_extensions.Literal["currency"]) -> typing.Union[MetaOapg.properties.currency, schemas.Unset]: ...
                                                    
                                                    @typing.overload
                                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                                    
                                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "type", "value", "currency", ], str]):
                                                        return super().get_item_oapg(name)
                                                    
                                                
                                                    def __new__(
                                                        cls,
                                                        *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                        type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
                                                        value: typing.Union[MetaOapg.properties.value, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                                        currency: typing.Union[MetaOapg.properties.currency, str, schemas.Unset] = schemas.unset,
                                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                                    ) -> 'items':
                                                        return super().__new__(
                                                            cls,
                                                            *args,
                                                            name=name,
                                                            type=type,
                                                            value=value,
                                                            currency=currency,
                                                            _configuration=_configuration,
                                                            **kwargs,
                                                        )
                                        
                                            def __new__(
                                                cls,
                                                arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                            ) -> 'breakdowns':
                                                return super().__new__(
                                                    cls,
                                                    arg,
                                                    _configuration=_configuration,
                                                )
                                        
                                            def __getitem__(self, i: int) -> MetaOapg.items:
                                                return super().__getitem__(i)
                                    
                                        @staticmethod
                                        def customFields() -> typing.Type['CustomFieldsResponse']:
                                            return CustomFieldsResponse
                                        __annotations__ = {
                                            "type": type,
                                            "baseAnnualSalary": baseAnnualSalary,
                                            "baseHourlyRate": baseHourlyRate,
                                            "currency": currency,
                                            "hoursPerCycle": hoursPerCycle,
                                            "payCycle": payCycle,
                                            "annualPackage": annualPackage,
                                            "hourlyPackage": hourlyPackage,
                                            "currencyConversionOccurred": currencyConversionOccurred,
                                            "employmentCondition": employmentCondition,
                                            "additions": additions,
                                            "deductions": deductions,
                                            "additionsToTotal": additionsToTotal,
                                            "breakdowns": breakdowns,
                                            "customFields": customFields,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["baseAnnualSalary"]) -> MetaOapg.properties.baseAnnualSalary: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["baseHourlyRate"]) -> MetaOapg.properties.baseHourlyRate: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["currency"]) -> MetaOapg.properties.currency: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["hoursPerCycle"]) -> MetaOapg.properties.hoursPerCycle: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["payCycle"]) -> MetaOapg.properties.payCycle: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["annualPackage"]) -> MetaOapg.properties.annualPackage: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["hourlyPackage"]) -> MetaOapg.properties.hourlyPackage: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["currencyConversionOccurred"]) -> MetaOapg.properties.currencyConversionOccurred: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["employmentCondition"]) -> MetaOapg.properties.employmentCondition: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["additions"]) -> MetaOapg.properties.additions: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["deductions"]) -> MetaOapg.properties.deductions: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["additionsToTotal"]) -> MetaOapg.properties.additionsToTotal: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["breakdowns"]) -> MetaOapg.properties.breakdowns: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["customFields"]) -> 'CustomFieldsResponse': ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["type", "baseAnnualSalary", "baseHourlyRate", "currency", "hoursPerCycle", "payCycle", "annualPackage", "hourlyPackage", "currencyConversionOccurred", "employmentCondition", "additions", "deductions", "additionsToTotal", "breakdowns", "customFields", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["baseAnnualSalary"]) -> typing.Union[MetaOapg.properties.baseAnnualSalary, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["baseHourlyRate"]) -> typing.Union[MetaOapg.properties.baseHourlyRate, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["currency"]) -> typing.Union[MetaOapg.properties.currency, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["hoursPerCycle"]) -> typing.Union[MetaOapg.properties.hoursPerCycle, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["payCycle"]) -> typing.Union[MetaOapg.properties.payCycle, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["annualPackage"]) -> typing.Union[MetaOapg.properties.annualPackage, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["hourlyPackage"]) -> typing.Union[MetaOapg.properties.hourlyPackage, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["currencyConversionOccurred"]) -> typing.Union[MetaOapg.properties.currencyConversionOccurred, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["employmentCondition"]) -> typing.Union[MetaOapg.properties.employmentCondition, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["additions"]) -> typing.Union[MetaOapg.properties.additions, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["deductions"]) -> typing.Union[MetaOapg.properties.deductions, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["additionsToTotal"]) -> typing.Union[MetaOapg.properties.additionsToTotal, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["breakdowns"]) -> typing.Union[MetaOapg.properties.breakdowns, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["customFields"]) -> typing.Union['CustomFieldsResponse', schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["type", "baseAnnualSalary", "baseHourlyRate", "currency", "hoursPerCycle", "payCycle", "annualPackage", "hourlyPackage", "currencyConversionOccurred", "employmentCondition", "additions", "deductions", "additionsToTotal", "breakdowns", "customFields", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
                                    baseAnnualSalary: typing.Union[MetaOapg.properties.baseAnnualSalary, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                    baseHourlyRate: typing.Union[MetaOapg.properties.baseHourlyRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                    currency: typing.Union[MetaOapg.properties.currency, str, schemas.Unset] = schemas.unset,
                                    hoursPerCycle: typing.Union[MetaOapg.properties.hoursPerCycle, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                    payCycle: typing.Union[MetaOapg.properties.payCycle, str, schemas.Unset] = schemas.unset,
                                    annualPackage: typing.Union[MetaOapg.properties.annualPackage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                    hourlyPackage: typing.Union[MetaOapg.properties.hourlyPackage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                    currencyConversionOccurred: typing.Union[MetaOapg.properties.currencyConversionOccurred, bool, schemas.Unset] = schemas.unset,
                                    employmentCondition: typing.Union[MetaOapg.properties.employmentCondition, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                                    additions: typing.Union[MetaOapg.properties.additions, list, tuple, schemas.Unset] = schemas.unset,
                                    deductions: typing.Union[MetaOapg.properties.deductions, list, tuple, schemas.Unset] = schemas.unset,
                                    additionsToTotal: typing.Union[MetaOapg.properties.additionsToTotal, list, tuple, schemas.Unset] = schemas.unset,
                                    breakdowns: typing.Union[MetaOapg.properties.breakdowns, list, tuple, schemas.Unset] = schemas.unset,
                                    customFields: typing.Union['CustomFieldsResponse', schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        type=type,
                                        baseAnnualSalary=baseAnnualSalary,
                                        baseHourlyRate=baseHourlyRate,
                                        currency=currency,
                                        hoursPerCycle=hoursPerCycle,
                                        payCycle=payCycle,
                                        annualPackage=annualPackage,
                                        hourlyPackage=hourlyPackage,
                                        currencyConversionOccurred=currencyConversionOccurred,
                                        employmentCondition=employmentCondition,
                                        additions=additions,
                                        deductions=deductions,
                                        additionsToTotal=additionsToTotal,
                                        breakdowns=breakdowns,
                                        customFields=customFields,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'remunerationSchedules':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class supervisors(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'supervisors':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class workClasses(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'workClasses':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class workTypes(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'workTypes':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class directReportsRemoved(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'directReportsRemoved':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class directReportsAssigned(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        link = schemas.StrSchema
                                        __annotations__ = {
                                            "id": id,
                                            "link": link,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "link", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        id=id,
                                        link=link,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'directReportsAssigned':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class extendedLeaveStarted(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    
                    class one_of_0(
                        schemas.DictSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            class properties:
                                
                                
                                class id(
                                    schemas.StrSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        max_length = 36
                                        min_length = 36
                                
                                
                                class leaveType(
                                    schemas.DictSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        
                                        class properties:
                                            
                                            
                                            class id(
                                                schemas.StrSchema
                                            ):
                                            
                                            
                                                class MetaOapg:
                                                    max_length = 36
                                                    min_length = 36
                                            name = schemas.StrSchema
                                            link = schemas.StrSchema
                                            __annotations__ = {
                                                "id": id,
                                                "name": name,
                                                "link": link,
                                            }
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                    
                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                        # dict_instance[name] accessor
                                        return super().__getitem__(name)
                                    
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                    
                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                        return super().get_item_oapg(name)
                                    
                                
                                    def __new__(
                                        cls,
                                        *args: typing.Union[dict, frozendict.frozendict, ],
                                        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                        link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                    ) -> 'leaveType':
                                        return super().__new__(
                                            cls,
                                            *args,
                                            id=id,
                                            name=name,
                                            link=link,
                                            _configuration=_configuration,
                                            **kwargs,
                                        )
                                isEndDateConfirmed = schemas.BoolSchema
                                __annotations__ = {
                                    "id": id,
                                    "leaveType": leaveType,
                                    "isEndDateConfirmed": isEndDateConfirmed,
                                }
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["leaveType"]) -> MetaOapg.properties.leaveType: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["isEndDateConfirmed"]) -> MetaOapg.properties.isEndDateConfirmed: ...
                        
                        @typing.overload
                        def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                        
                        def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "leaveType", "isEndDateConfirmed", ], str]):
                            # dict_instance[name] accessor
                            return super().__getitem__(name)
                        
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["leaveType"]) -> typing.Union[MetaOapg.properties.leaveType, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["isEndDateConfirmed"]) -> typing.Union[MetaOapg.properties.isEndDateConfirmed, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                        
                        def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "leaveType", "isEndDateConfirmed", ], str]):
                            return super().get_item_oapg(name)
                        
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, ],
                            id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                            leaveType: typing.Union[MetaOapg.properties.leaveType, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                            isEndDateConfirmed: typing.Union[MetaOapg.properties.isEndDateConfirmed, bool, schemas.Unset] = schemas.unset,
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'one_of_0':
                            return super().__new__(
                                cls,
                                *args,
                                id=id,
                                leaveType=leaveType,
                                isEndDateConfirmed=isEndDateConfirmed,
                                _configuration=_configuration,
                                **kwargs,
                            )
                    one_of_1 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'extendedLeaveStarted':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class extendedLeaveEnded(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    
                    class one_of_0(
                        schemas.DictSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            class properties:
                                
                                
                                class id(
                                    schemas.StrSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        max_length = 36
                                        min_length = 36
                                
                                
                                class leaveType(
                                    schemas.DictSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        
                                        class properties:
                                            
                                            
                                            class id(
                                                schemas.StrSchema
                                            ):
                                            
                                            
                                                class MetaOapg:
                                                    max_length = 36
                                                    min_length = 36
                                            name = schemas.StrSchema
                                            link = schemas.StrSchema
                                            __annotations__ = {
                                                "id": id,
                                                "name": name,
                                                "link": link,
                                            }
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                    
                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                        # dict_instance[name] accessor
                                        return super().__getitem__(name)
                                    
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                    
                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                        return super().get_item_oapg(name)
                                    
                                
                                    def __new__(
                                        cls,
                                        *args: typing.Union[dict, frozendict.frozendict, ],
                                        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                        link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                    ) -> 'leaveType':
                                        return super().__new__(
                                            cls,
                                            *args,
                                            id=id,
                                            name=name,
                                            link=link,
                                            _configuration=_configuration,
                                            **kwargs,
                                        )
                                isEndDateConfirmed = schemas.BoolSchema
                                __annotations__ = {
                                    "id": id,
                                    "leaveType": leaveType,
                                    "isEndDateConfirmed": isEndDateConfirmed,
                                }
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["leaveType"]) -> MetaOapg.properties.leaveType: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["isEndDateConfirmed"]) -> MetaOapg.properties.isEndDateConfirmed: ...
                        
                        @typing.overload
                        def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                        
                        def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "leaveType", "isEndDateConfirmed", ], str]):
                            # dict_instance[name] accessor
                            return super().__getitem__(name)
                        
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["leaveType"]) -> typing.Union[MetaOapg.properties.leaveType, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["isEndDateConfirmed"]) -> typing.Union[MetaOapg.properties.isEndDateConfirmed, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                        
                        def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "leaveType", "isEndDateConfirmed", ], str]):
                            return super().get_item_oapg(name)
                        
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, ],
                            id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                            leaveType: typing.Union[MetaOapg.properties.leaveType, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                            isEndDateConfirmed: typing.Union[MetaOapg.properties.isEndDateConfirmed, bool, schemas.Unset] = schemas.unset,
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'one_of_0':
                            return super().__new__(
                                cls,
                                *args,
                                id=id,
                                leaveType=leaveType,
                                isEndDateConfirmed=isEndDateConfirmed,
                                _configuration=_configuration,
                                **kwargs,
                            )
                    one_of_1 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'extendedLeaveEnded':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            isFirstChange = schemas.BoolSchema
            
            
            class comments(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    
                    class one_of_0(
                        schemas.ListSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            
                            class items(
                                schemas.AnyTypeSchema,
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        description = schemas.AnyTypeSchema
                                        
                                        
                                        class id(
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                max_length = 36
                                                min_length = 36
                                        date = schemas.AnyTypeSchema
                                        
                                        
                                        class jobChangeReason(
                                            schemas.DictSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                class properties:
                                                    
                                                    
                                                    class id(
                                                        schemas.StrSchema
                                                    ):
                                                    
                                                    
                                                        class MetaOapg:
                                                            max_length = 36
                                                            min_length = 36
                                                    name = schemas.StrSchema
                                                    link = schemas.StrSchema
                                                    __annotations__ = {
                                                        "id": id,
                                                        "name": name,
                                                        "link": link,
                                                    }
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["link"]) -> MetaOapg.properties.link: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                            
                                            def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                                # dict_instance[name] accessor
                                                return super().__getitem__(name)
                                            
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["link"]) -> typing.Union[MetaOapg.properties.link, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                            
                                            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "link", ], str]):
                                                return super().get_item_oapg(name)
                                            
                                        
                                            def __new__(
                                                cls,
                                                *args: typing.Union[dict, frozendict.frozendict, ],
                                                id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                                name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
                                                link: typing.Union[MetaOapg.properties.link, str, schemas.Unset] = schemas.unset,
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'jobChangeReason':
                                                return super().__new__(
                                                    cls,
                                                    *args,
                                                    id=id,
                                                    name=name,
                                                    link=link,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                        __annotations__ = {
                                            "description": description,
                                            "id": id,
                                            "date": date,
                                            "jobChangeReason": jobChangeReason,
                                        }
                            
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["date"]) -> MetaOapg.properties.date: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["jobChangeReason"]) -> MetaOapg.properties.jobChangeReason: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["description", "id", "date", "jobChangeReason", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["date"]) -> typing.Union[MetaOapg.properties.date, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["jobChangeReason"]) -> typing.Union[MetaOapg.properties.jobChangeReason, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["description", "id", "date", "jobChangeReason", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                    description: typing.Union[MetaOapg.properties.description, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
                                    id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
                                    date: typing.Union[MetaOapg.properties.date, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
                                    jobChangeReason: typing.Union[MetaOapg.properties.jobChangeReason, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'items':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        description=description,
                                        id=id,
                                        date=date,
                                        jobChangeReason=jobChangeReason,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                    
                        def __new__(
                            cls,
                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'one_of_0':
                            return super().__new__(
                                cls,
                                arg,
                                _configuration=_configuration,
                            )
                    
                        def __getitem__(self, i: int) -> MetaOapg.items:
                            return super().__getitem__(i)
                    one_of_1 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'comments':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            isStartOfJob = schemas.BoolSchema
            isEndOfProbation = schemas.BoolSchema
            isEndOfJob = schemas.BoolSchema
            
            
            class turnoverType(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_0 = schemas.StrSchema
                    one_of_1 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'turnoverType':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class turnoverReason(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_0 = schemas.StrSchema
                    one_of_1 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'turnoverReason':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class customFields(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.NoneSchema
                            
                            
                            class one_of_1(
                                schemas.DictSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                    
                                        @staticmethod
                                        def _from() -> typing.Type['CustomFieldsResponse']:
                                            return CustomFieldsResponse
                                    
                                        @staticmethod
                                        def to() -> typing.Type['CustomFieldsResponse']:
                                            return CustomFieldsResponse
                                        __annotations__ = {
                                            "from": _from,
                                            "to": to,
                                        }
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["from"]) -> 'CustomFieldsResponse': ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["to"]) -> 'CustomFieldsResponse': ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["from", "to", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["from"]) -> typing.Union['CustomFieldsResponse', schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["to"]) -> typing.Union['CustomFieldsResponse', schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["from", "to", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, ],
                                    to: typing.Union['CustomFieldsResponse', schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'one_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        to=to,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    cls.one_of_1,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'customFields':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            __annotations__ = {
                "groupTime": groupTime,
                "businessUnits": businessUnits,
                "businessEntities": businessEntities,
                "ftes": ftes,
                "locations": locations,
                "positionTitles": positionTitles,
                "payGrades": payGrades,
                "renamedPayGrades": renamedPayGrades,
                "remunerationSchedules": remunerationSchedules,
                "supervisors": supervisors,
                "workClasses": workClasses,
                "workTypes": workTypes,
                "directReportsRemoved": directReportsRemoved,
                "directReportsAssigned": directReportsAssigned,
                "extendedLeaveStarted": extendedLeaveStarted,
                "extendedLeaveEnded": extendedLeaveEnded,
                "isFirstChange": isFirstChange,
                "comments": comments,
                "isStartOfJob": isStartOfJob,
                "isEndOfProbation": isEndOfProbation,
                "isEndOfJob": isEndOfJob,
                "turnoverType": turnoverType,
                "turnoverReason": turnoverReason,
                "customFields": customFields,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["groupTime"]) -> MetaOapg.properties.groupTime: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["businessUnits"]) -> MetaOapg.properties.businessUnits: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["businessEntities"]) -> MetaOapg.properties.businessEntities: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ftes"]) -> MetaOapg.properties.ftes: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["locations"]) -> MetaOapg.properties.locations: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["positionTitles"]) -> MetaOapg.properties.positionTitles: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["payGrades"]) -> MetaOapg.properties.payGrades: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["renamedPayGrades"]) -> MetaOapg.properties.renamedPayGrades: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["remunerationSchedules"]) -> MetaOapg.properties.remunerationSchedules: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["supervisors"]) -> MetaOapg.properties.supervisors: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["workClasses"]) -> MetaOapg.properties.workClasses: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["workTypes"]) -> MetaOapg.properties.workTypes: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["directReportsRemoved"]) -> MetaOapg.properties.directReportsRemoved: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["directReportsAssigned"]) -> MetaOapg.properties.directReportsAssigned: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["extendedLeaveStarted"]) -> MetaOapg.properties.extendedLeaveStarted: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["extendedLeaveEnded"]) -> MetaOapg.properties.extendedLeaveEnded: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["isFirstChange"]) -> MetaOapg.properties.isFirstChange: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["comments"]) -> MetaOapg.properties.comments: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["isStartOfJob"]) -> MetaOapg.properties.isStartOfJob: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["isEndOfProbation"]) -> MetaOapg.properties.isEndOfProbation: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["isEndOfJob"]) -> MetaOapg.properties.isEndOfJob: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["turnoverType"]) -> MetaOapg.properties.turnoverType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["turnoverReason"]) -> MetaOapg.properties.turnoverReason: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["customFields"]) -> MetaOapg.properties.customFields: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["groupTime", "businessUnits", "businessEntities", "ftes", "locations", "positionTitles", "payGrades", "renamedPayGrades", "remunerationSchedules", "supervisors", "workClasses", "workTypes", "directReportsRemoved", "directReportsAssigned", "extendedLeaveStarted", "extendedLeaveEnded", "isFirstChange", "comments", "isStartOfJob", "isEndOfProbation", "isEndOfJob", "turnoverType", "turnoverReason", "customFields", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["groupTime"]) -> typing.Union[MetaOapg.properties.groupTime, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["businessUnits"]) -> typing.Union[MetaOapg.properties.businessUnits, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["businessEntities"]) -> typing.Union[MetaOapg.properties.businessEntities, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ftes"]) -> typing.Union[MetaOapg.properties.ftes, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["locations"]) -> typing.Union[MetaOapg.properties.locations, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["positionTitles"]) -> typing.Union[MetaOapg.properties.positionTitles, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["payGrades"]) -> typing.Union[MetaOapg.properties.payGrades, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["renamedPayGrades"]) -> typing.Union[MetaOapg.properties.renamedPayGrades, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["remunerationSchedules"]) -> typing.Union[MetaOapg.properties.remunerationSchedules, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["supervisors"]) -> typing.Union[MetaOapg.properties.supervisors, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["workClasses"]) -> typing.Union[MetaOapg.properties.workClasses, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["workTypes"]) -> typing.Union[MetaOapg.properties.workTypes, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["directReportsRemoved"]) -> typing.Union[MetaOapg.properties.directReportsRemoved, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["directReportsAssigned"]) -> typing.Union[MetaOapg.properties.directReportsAssigned, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["extendedLeaveStarted"]) -> typing.Union[MetaOapg.properties.extendedLeaveStarted, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["extendedLeaveEnded"]) -> typing.Union[MetaOapg.properties.extendedLeaveEnded, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["isFirstChange"]) -> typing.Union[MetaOapg.properties.isFirstChange, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["comments"]) -> typing.Union[MetaOapg.properties.comments, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["isStartOfJob"]) -> typing.Union[MetaOapg.properties.isStartOfJob, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["isEndOfProbation"]) -> typing.Union[MetaOapg.properties.isEndOfProbation, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["isEndOfJob"]) -> typing.Union[MetaOapg.properties.isEndOfJob, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["turnoverType"]) -> typing.Union[MetaOapg.properties.turnoverType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["turnoverReason"]) -> typing.Union[MetaOapg.properties.turnoverReason, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["customFields"]) -> typing.Union[MetaOapg.properties.customFields, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["groupTime", "businessUnits", "businessEntities", "ftes", "locations", "positionTitles", "payGrades", "renamedPayGrades", "remunerationSchedules", "supervisors", "workClasses", "workTypes", "directReportsRemoved", "directReportsAssigned", "extendedLeaveStarted", "extendedLeaveEnded", "isFirstChange", "comments", "isStartOfJob", "isEndOfProbation", "isEndOfJob", "turnoverType", "turnoverReason", "customFields", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        groupTime: typing.Union[MetaOapg.properties.groupTime, str, schemas.Unset] = schemas.unset,
        businessUnits: typing.Union[MetaOapg.properties.businessUnits, list, tuple, schemas.Unset] = schemas.unset,
        businessEntities: typing.Union[MetaOapg.properties.businessEntities, list, tuple, schemas.Unset] = schemas.unset,
        ftes: typing.Union[MetaOapg.properties.ftes, list, tuple, schemas.Unset] = schemas.unset,
        locations: typing.Union[MetaOapg.properties.locations, list, tuple, schemas.Unset] = schemas.unset,
        positionTitles: typing.Union[MetaOapg.properties.positionTitles, list, tuple, schemas.Unset] = schemas.unset,
        payGrades: typing.Union[MetaOapg.properties.payGrades, list, tuple, schemas.Unset] = schemas.unset,
        renamedPayGrades: typing.Union[MetaOapg.properties.renamedPayGrades, list, tuple, schemas.Unset] = schemas.unset,
        remunerationSchedules: typing.Union[MetaOapg.properties.remunerationSchedules, list, tuple, schemas.Unset] = schemas.unset,
        supervisors: typing.Union[MetaOapg.properties.supervisors, list, tuple, schemas.Unset] = schemas.unset,
        workClasses: typing.Union[MetaOapg.properties.workClasses, list, tuple, schemas.Unset] = schemas.unset,
        workTypes: typing.Union[MetaOapg.properties.workTypes, list, tuple, schemas.Unset] = schemas.unset,
        directReportsRemoved: typing.Union[MetaOapg.properties.directReportsRemoved, list, tuple, schemas.Unset] = schemas.unset,
        directReportsAssigned: typing.Union[MetaOapg.properties.directReportsAssigned, list, tuple, schemas.Unset] = schemas.unset,
        extendedLeaveStarted: typing.Union[MetaOapg.properties.extendedLeaveStarted, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        extendedLeaveEnded: typing.Union[MetaOapg.properties.extendedLeaveEnded, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        isFirstChange: typing.Union[MetaOapg.properties.isFirstChange, bool, schemas.Unset] = schemas.unset,
        comments: typing.Union[MetaOapg.properties.comments, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        isStartOfJob: typing.Union[MetaOapg.properties.isStartOfJob, bool, schemas.Unset] = schemas.unset,
        isEndOfProbation: typing.Union[MetaOapg.properties.isEndOfProbation, bool, schemas.Unset] = schemas.unset,
        isEndOfJob: typing.Union[MetaOapg.properties.isEndOfJob, bool, schemas.Unset] = schemas.unset,
        turnoverType: typing.Union[MetaOapg.properties.turnoverType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        turnoverReason: typing.Union[MetaOapg.properties.turnoverReason, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        customFields: typing.Union[MetaOapg.properties.customFields, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'JobIdTimelineGetResponseDataItem':
        return super().__new__(
            cls,
            *args,
            groupTime=groupTime,
            businessUnits=businessUnits,
            businessEntities=businessEntities,
            ftes=ftes,
            locations=locations,
            positionTitles=positionTitles,
            payGrades=payGrades,
            renamedPayGrades=renamedPayGrades,
            remunerationSchedules=remunerationSchedules,
            supervisors=supervisors,
            workClasses=workClasses,
            workTypes=workTypes,
            directReportsRemoved=directReportsRemoved,
            directReportsAssigned=directReportsAssigned,
            extendedLeaveStarted=extendedLeaveStarted,
            extendedLeaveEnded=extendedLeaveEnded,
            isFirstChange=isFirstChange,
            comments=comments,
            isStartOfJob=isStartOfJob,
            isEndOfProbation=isEndOfProbation,
            isEndOfJob=isEndOfJob,
            turnoverType=turnoverType,
            turnoverReason=turnoverReason,
            customFields=customFields,
            _configuration=_configuration,
            **kwargs,
        )

from intelli_hr_python_sdk.model.custom_fields_response import CustomFieldsResponse
