# coding: utf-8

"""
    intelliHR Public API

    You can find developer's guide and more documentation on [https://developers.intellihr.io](https://developers.intellihr.io)

    The version of the OpenAPI document: V1
    Contact: support@intellihr.co
    Generated by: https://konfigthis.com
"""

from datetime import datetime, date
import typing
from enum import Enum
from typing_extensions import TypedDict, Literal, TYPE_CHECKING
from pydantic import BaseModel, Field, RootModel, ConfigDict

from intelli_hr_python_sdk.pydantic.custom_fields_response import CustomFieldsResponse

class JobIdTimelineGetResponseDataItem(BaseModel):
    # The timestamp of the group of timeline events. This date will follow the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6).
    group_time: typing.Optional[str] = Field(None, alias='groupTime')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    business_units: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='businessUnits')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    business_entities: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='businessEntities')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    ftes: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='ftes')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    locations: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='locations')

    position_titles: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='positionTitles')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    pay_grades: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='payGrades')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    renamed_pay_grades: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='renamedPayGrades')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    remuneration_schedules: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='remunerationSchedules')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    supervisors: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='supervisors')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    work_classes: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='workClasses')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    work_types: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='workTypes')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    direct_reports_removed: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='directReportsRemoved')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    direct_reports_assigned: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='directReportsAssigned')

    extended_leave_started: typing.Optional[typing.Union[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]] = Field(None, alias='extendedLeaveStarted')

    extended_leave_ended: typing.Optional[typing.Union[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]] = Field(None, alias='extendedLeaveEnded')

    # If this event group contains the first change of job attributes (e.g. when a job starts)
    is_first_change: typing.Optional[bool] = Field(None, alias='isFirstChange')

    # An array of comment objects that annotate the reason for [Job](https://developers.intellihr.io/docs/v1/) changes. Will be an empty array when there has been no updates to the Job.
    comments: typing.Optional[typing.Union[typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]], none_type]] = Field(None, alias='comments')

    # If this event group is the start of the given job
    is_start_of_job: typing.Optional[bool] = Field(None, alias='isStartOfJob')

    # If this event group is the end of the jobs probation period
    is_end_of_probation: typing.Optional[bool] = Field(None, alias='isEndOfProbation')

    # If this event group is the end of the given job
    is_end_of_job: typing.Optional[bool] = Field(None, alias='isEndOfJob')

    # The type of turnover this end of job is classified as.
    turnover_type: typing.Optional[typing.Union[str, none_type]] = Field(None, alias='turnoverType')

    # The name of the turnover reason.
    turnover_reason: typing.Optional[typing.Union[str, none_type]] = Field(None, alias='turnoverReason')

    # The array is in the following format: [From, To, From, To] every even index is the From record, odd the To record.
    custom_fields: typing.Optional[typing.List[typing.Union[typing.List[none_type], typing.List[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]]]]] = Field(None, alias='customFields')

    model_config = ConfigDict(
        protected_namespaces=(),
        arbitrary_types_allowed=True
    )
